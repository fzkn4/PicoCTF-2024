# FORMAT STRING 1
![format_string_1](https://github.com/fzkn4/PicoCTF-2024/assets/147215607/5e437f44-76e9-4698-809a-194e1ef4c8df)

In this challenge, we will dive deeper into `format string vulnerabilities` and how we can use this to leak informations on the stack.
#
> First, Let's run the program and see what it does:
![format_string_1_pic1](https://github.com/fzkn4/PicoCTF-2024/assets/147215607/ea2a28ed-ac05-43ad-8301-d1ea824f3798)

The program asks for an input and prints whatever input we proviide.
>Let's take a look at the source code:
![format_string_1_pic2](https://github.com/fzkn4/PicoCTF-2024/assets/147215607/777086b6-192e-4623-bec7-75b5cf309bb4)

Here, we can see that in `line 36` is a format string vulnerability, why? Let's find out.

> What is Format string vulnerability?

A `format string vulnerability` is a bug where user input is passed as the format argument to `printf, scanf`, or another function in that family.

Format strings are strings that contain `format specifiers`. They are used in format functions in C and in many other programming languages.

Format specifiers in a format string are `placeholders` that will be replaced with a piece of data that the developer passes in.

For example, the following code snippet shows how printf() in C works. The statement will output different sentences, depending on what is contained in the variable name.

`printf("Flag is: %s", flag);`
If we supply `Flag` as an input, we get: `Flag is: Flag`.

So what will happen if there is `no format specifier` given similar to `line 36` in the source code?
#
Watch what happens if we try a format specifier as an input?
> ![format_string_1_pic3](https://github.com/fzkn4/PicoCTF-2024/assets/147215607/9cac9aae-dced-4178-9521-53907fdb8b8c)

It prints random negative decimals.
#
Now, what will happen if we provide `%s` as an input?
> ![format_string_1_pic4](https://github.com/fzkn4/PicoCTF-2024/assets/147215607/c1ce68ca-24c1-44cf-b6e5-432c3da67bd9)

It gave us nothing.
#
Let's try a couple more `%s`:
> ![format_string_1_pic6](https://github.com/fzkn4/PicoCTF-2024/assets/147215607/aed1aef7-221f-4a6e-8346-65145f4f22b0)

It gave us `Segmentation fault`. This happens if we try to print an invalid string out of the stack.
#
Now let's try format specifier for hexadecimal `%x`:
> ![format_string_1_pic7](https://github.com/fzkn4/PicoCTF-2024/assets/147215607/2ac3e5ba-f882-4624-b692-a7631854ced9)

If we try and `unhex` all the output, we can find that the `14th` element converts into `galf`. Which we know in reverse, its `flag`. This is because it's in `little endian`    format. We can also do `%[position]$x` to get the specific element in the stack and print in hexadecimal value. 

Now if we provide `%14$lx.%15$lx.%16$lx.%17$lx.%18$lx` as an input, we will get: `7B4654436F636970 355F31346D316E34 3478345F33317937 31395F673431665F 7D653464663533`. However, it's still in a little endian format, so we still have to reverse it's position.
Finally, we `unhex` it to get the flag.
# 
Flag: `picoCTF{4n1m41_57y13_4x4_f14g_9135fd4e}`

